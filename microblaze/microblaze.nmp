// TODO:
// Support MSRs properly
// Implement FPU

let proc    = "microblaze"
let gliss_isize = "32"
let bit_order = "uppermost"

// Types
type dword = card(64)
type word = card(32)
type half = card(16)
type byte = card(8)
type bit = card(1)

type u32 = card(32)
type s32 = int(32)
type u16 = card(16)
type u8  = card(8)

type imm16 = card(16)

type reg_num = card(5)

let NUM_GPR = 32
let NUM_SPR = 27	
let MEM_ADDR_SIZE = 32

// Register file
reg R [ NUM_GPR, word ]
reg S [ NUM_SPR, word ]
reg PC [ 1, word ] pc=1   // Program counter 
reg nPC [ 1, word ] npc = 1       // Next program counter

// Global memory
mem M [ MEM_ADDR_SIZE, u8 ] progmem=1

// SPR aliases
reg MSR   [ 1, word ] alias = S[1]
reg EAR   [ 1, word ] alias = S[2]
reg ESR   [ 1, word ] alias = S[3]
reg FSR   [ 1, word ] alias = S[4]
reg BTR   [ 1, word ] alias = S[5]
reg EDR   [ 1, word ] alias = S[6]
reg SLR   [ 1, word ] alias = S[7]
reg SHR   [ 1, word ] alias = S[8]
reg PID   [ 1, word ] alias = S[9]
reg ZPR   [ 1, word ] alias = S[10]
reg TLBX  [ 1, word ] alias = S[11]
reg TLBLO [ 1, word ] alias = S[12]
reg TLBHI [ 1, word ] alias = S[13]
reg PVR0  [ 1, word ] alias = S[14]
reg PVR1  [ 1, word ] alias = S[15]
reg PVR2  [ 1, word ] alias = S[16]
reg PVR3  [ 1, word ] alias = S[17]
reg PVR4  [ 1, word ] alias = S[18]
reg PVR5  [ 1, word ] alias = S[19]
reg PVR6  [ 1, word ] alias = S[20]
reg PVR7  [ 1, word ] alias = S[21]
reg PVR8  [ 1, word ] alias = S[22]
reg PVR9  [ 1, word ] alias = S[23]
reg PVR10 [ 1, word ] alias = S[24]
reg PVR11 [ 1, word ] alias = S[25]
reg PVR12 [ 1, word ] alias = S[26]

// GPR aliases
reg RSP   [ 1, word ] alias = R[1]
reg RLR   [ 1, word ] alias = R[15]

// Temporaries
reg _rDST  [ 1, dword ] // DWord so that carry can be calculated

// Carry bit
reg C [ 1, bit ]

// Linked branch support
reg DB   [ 1, bit ]   // Delayed branch?
reg B    [ 1, bit ]   // Branch taken?
reg Btgt [ 1, word ]  // Branch target

// Upper 16 latch
reg immHigh [ 1, word ]
reg immHighValid [ 1, bit ]
reg immTmp [ 1, s32 ] // Temporary to add on the upper bits...

mode reg_idx(i: card(5)) = R[i]
	syntax = format("r%d", i)
	image = format("%5b", i)
	is_zero = i == 0

mode reg_idx0(i: card(5)) = if i == 0 then 0 else R[i] endif
	syntax = format("r%d", i)
	image = format("%5b", i)
	is_zero = i == 0

// Macro for sign extending an unsigned value of size bits to a signed 32bit/64bit value
macro sext32(value, size) = (coerce(int(32), value) << (32-size)) >> (32-size)
macro sext64(value, size) = (coerce(int(64), value) << (64-size)) >> (64-size)
macro buildImm(immLow) = \
	if immHighValid == 1 then \
		immHigh | immLow \
	else \
		sext32(immLow, 16) \
	endif

// Startup
op init()
	action = 
		{
			//R[0] = 0;
			PC = 0;
			nPC = 4;
		}

// Normal instructions
// Base instruction
op instruction(x: MBlaze_instr)
	syntax = x.syntax
	image = x.image
	action = {
		x.action;

		if B == 1 then
			PC = Btgt;
		else
			PC = nPC;
		endif;

		if DB == 1 then
			nPC = Btgt;
			DB = 0;
		else
			if B == 1 then
				nPC = Btgt + 4;
			else
				nPC = nPC + 4;
			endif;
		endif;

		B = 0;
	}

op MBlaze_instr = MBlaze_typeA | MBlaze_typeB

op MBlaze_typeA = MBlaze_typeA_ALU
				| MBlaze_typeA_MUL
				| MBlaze_typeA_BSL
				| MBlaze_typeA_GETPUTD       // Indirect GET/PUT
				| MBlaze_typeA_logic      // OR/AND etc
				| MBlaze_typeA_PCMP       // Pattern matcher
				| MBlaze_typeA_BR         // Unconditional branch
				| MBlaze_typeA_BRC        // Conditional branch
				| MBlaze_typeA_LD         // Loads
				| MBlaze_typeA_ST         // Stores

op MBlaze_typeB = MBlaze_typeB_ALU
                | MBlaze_typeB_MUL
                | MBlaze_typeB_BSL
                | MBlaze_typeB_GET
                | MBlaze_typeB_PUT
                | MBlaze_typeB_UTIL       // Misc bit operations
                | MBlaze_typeB_MTS
                | MBlaze_typeB_MFS
                | MBlaze_typeB_logic      // OR/AND etc
                | MBlaze_typeB_IMM
                | MBlaze_typeB_RET        // Returns
                | MBlaze_typeB_BR
                | MBlaze_typeB_BRC
                | MBlaze_typeB_LDI
                | MBlaze_typeB_STI

op MBlaze_typeA_ALU(keep: bit, carry: bit, rsub: bit, rD: reg_idx, rA: reg_idx0, rB: reg_idx0, extra: card(11))
	syntax = 
		if rsub == 1 then
			if extra == 0 then
				if keep == 1  && carry == 1 then
					"rsubkc  "
				else 
					if keep == 1 then
						"rsubk   "
					else 
						if carry == 1 then
							"rsubc   "
						else
							"rsub    "
						endif
					endif
				endif
			else 
				if extra == 1 then
					"cmp     "
				else 
					if extra == 3 then
						"cmpu    "
					else
						"WUTLOL     "
					endif
				endif
			endif
		else
			if keep == 1  && carry == 1 then
				"addkc   "
			else 
				if keep == 1 then
					"addk    "
				else 
					if carry == 1 then
						"addc    "
					else
						"add     "
					endif
				endif
			endif
		endif

	image = format("000 %1b %1b %1b %s %s %s %11b", keep, carry, rsub, rD, rA, rB, extra)

	action = 
	{
		if rsub == 1 then
			_rDST = rB + ~rA + 1;
		else // Standard addition
			_rDST = rA + rB;
		endif;

		// Sort out carry
		if carry == 1 then
			if C == 1 then
				_rDST = _rDST + 1;
			endif;
		endif;

		if keep == 0 then
			if _rDST<32..32> == 1 then
				C = 1;
			else
				C = 0;
			endif;
		endif;

		rD = _rDST;
	}

op MBlaze_typeB_ALU(keep: bit, carry: bit, rsub: bit, rD: reg_idx, rA: reg_idx0, imm: imm16)
	syntax = 
		format("%s%s%s", (if rsub == 1 then "rsubi" else "addi" endif), (if keep == 1 then "k" else "" endif), (if carry == 1 then "c" else "" endif))

	image = format("001 %1b %1b %1b %s %s %16b", keep, carry, rsub, rD, rA, imm)

	action = 
	{
		// Add on the upper 16 bits
		immTmp = buildImm(imm);
		immHighValid = 0;

		if rsub == 1 then
			_rDST = immTmp + ~rA + 1;
		else // Standard addition
			_rDST = rA + immTmp;
		endif;

		// Sort out carry
		if carry == 1 then
			if C == 1 then
				_rDST = _rDST + 1;
			endif;
		endif;

		if keep == 0 then
			if _rDST<32..32> == 1 then
				C = 1;
			else
				C = 0;
			endif;
		endif;

		rD = _rDST;
	}

op MBlaze_typeA_MUL(rD: reg_idx, rA: reg_idx0, rB: reg_idx0, extra: card(11))
	syntax = 
		switch (extra)
		{
		case 0: "mul     "
		case 1: "mulh    "
		case 3: "mulhu   "
		case 2: "mulhsu  "
		default: "DEAD    "
		}

	image = format("010000 %s %s %s %11b", rD, rA, rB, extra)

	action = 
	{
		switch(extra)
		{
			case 0: _rDST = rA * rB;
			case 1: _rDST = (sext64(rA, 32) * sext64(rB, 32)) >> 32;
			case 3: _rDST = (coerce(card(64), rA) * coerce(card(64), rB)) >> 32;
			case 2: _rDST = (sext64(rA, 32) * coerce(card(64), rB)) >> 32;
		};

		rD = _rDST;
	}

op MBlaze_typeB_MUL(rD: reg_idx, rA: reg_idx0, imm: imm16)
	syntax = "muli    "

	image = format("011000 %s %s %16b", rD, rA, imm)

	action = 
	{
		immTmp = buildImm(imm);
		immHighValid = 0;

		rD = rA * immTmp;
		immHigh = 0;
	}

op MBlaze_typeA_BSL(rD: reg_idx, rA: reg_idx0, rB: reg_idx0, extra: card(11))
	syntax = 
		if extra == 0 then
			"bsrl    "
		else
			if extra<9..9> == 1 then
				"bsra    "
			else
				if extra<10..10> == 1 then
					"bsll    "
				else
					"DEAD"
				endif
			endif
		endif

	image = format("010001 %s %s %s %11b", rD, rA, rB, extra)

	action = 
	{
		if extra == 0 then
			rD = rA >> rB;
		else
			if extra<9..9> == 1 then
				rD = coerce(int(32), rA) >> rB;
			else
				if extra<10..10> == 1 then
					rD = rA << rB;
				endif;
			endif;
		endif;
	}

// I'm not implementing this properly for now...
// I don't actually know if this supports IO...
op MBlaze_typeA_GETPUTD(T: bit, N: bit, E: bit, A: bit, C: bit, rD: reg_num, rA: reg_num, rB: reg_num)
	syntax = format("%s%s%s%s%s%sd", 
					if T == 1 then "t" else "" endif,
				    if N == 1 then "n" else "" endif,
				    if E == 1 then "e" else "" endif,
				    if A == 1 then "a" else "" endif,
				    if C == 1 then "c" else "" endif,
					if rD > 0 then "get" else "put" endif)
	image = format("010011 %5b %5b %5b 0 %1b %1b %1b %1b %1b 00000", rD, rA, rB, N, C, T, A, E)

	action = 
	{
		if rD > 0 then
			R[rD] = 0xDEADBEEF;
		endif;
	}

op MBlaze_typeB_BSL(rD: reg_idx, rA: reg_idx0, extra: card(11), imm: card(5))
	syntax = 
		if extra == 0 then
			"bsrli   "
		else
			if extra<4..4> == 1 then
				"bsrai   "
			else
				if extra<5..5> == 1 then
					"bslli   "
				else
					"DEAD"
				endif
			endif
		endif

	image = format("011001 %s %s %11b %5b", rD, rA, extra, imm)

	action = 
	{
		if extra == 0 then
			rD = rA >> imm;
		else
			if extra<4..4> == 1 then
				rD = coerce(int(32), rA) >> imm;
			else
				if extra<5..5> == 1 then
					rD = rA << imm;
				endif;
			endif;
		endif;
	}

op MBlaze_typeB_GET(T: bit, N: bit, E: bit, A: bit, C: bit, rD: reg_idx, fsln: card(4))
	syntax = format("%s%s%s%s%sget", 
					if T == 1 then "t" else "" endif,
				    if N == 1 then "n" else "" endif,
				    if E == 1 then "e" else "" endif,
				    if A == 1 then "a" else "" endif,
				    if C == 1 then "c" else "" endif)

	image = format("011011 %s 00000 0 %1b %1b %1b %1b %1b 000000 %4b", rD, N, C, T, A, E, fsln)

	action = 
	{
		rD = 0xDEADBEEF;
	}

op MBlaze_typeB_PUT(T: bit, N: bit, E: bit, A: bit, C: bit, rA: reg_idx0, fsln: card(4))
	syntax = format("%s%s%s%s%sput", 
					if T == 1 then "t" else "" endif,
				    if N == 1 then "n" else "" endif,
				    if E == 1 then "e" else "" endif,
				    if A == 1 then "a" else "" endif,
				    if C == 1 then "c" else "" endif)

	image = format("011011 00000 %s 1 %1b %1b %1b %1b %1b 000000 %4b", rA, N, C, T, A, E, fsln)

	action = 
	{
		// NOP...
	}

op MBlaze_typeA_logic(opc: card(2), rD: reg_idx, rA: reg_idx0, rB: reg_idx0)
	syntax = switch(opc)
	{
		case 0: "or      "
		case 1: "and     "
		case 2: "xor     "
		case 3: "andn    "
	}

	image = format("1000 %2b %s %s %s 00000000000", opc, rD, rA, rB)

	action = 
	{
		switch(opc)
		{
			case 0: rD = rA | rB;
			case 1: rD = rA & rB;
			case 2: rD = rA ^ rB;
			case 3: rD = rA & ~rB;
		};
	}

op MBlaze_typeA_PCMP(opc: card(2), rD: reg_idx, rA: reg_idx0, rB: reg_idx0)
	syntax = switch(opc)
	{
		case 0: "pcmpbf  "
		case 1: "DEAD"
		case 2: "pcmpeq  "
		case 3: "pcmpne  "
	}

	image = format("1000 %2b %s %s %s 10000000000", opc, rD, rA, rB)

	action = 
	{
		switch(opc)
		{
		case 0:
			if rA<31..24> == rB<31..24> then
				rD = 1;
			else
				if rA<23..16> == rB<23..16> then
					rD = 2;
				else
					if rA<15..8> == rB<15..8> then
						rD = 3;
					else
						if rA<7..0> == rB<7..0> then
							rD = 4;
						else
							rD = 0;
						endif;
					endif;
				endif;
			endif;

		case 2:
			if rA == rB then
				rD = 1;
			else
				rD = 0;
			endif;
		case 3:
			if rA == rB then
				rD = 0;
			else
				rD = 1;
			endif;
		};
	}

// Since these all share opcodes, they need to be the same op to keep
// the compiler happy :(
// I'm also ignoring the caching opcodes for now.
op MBlaze_typeB_UTIL(rD: reg_idx, rA: reg_idx0, imm: imm16)
	syntax = 
		switch(imm)
		{
			case 0x0001: "sra     "
			case 0x0021: "src     "
			case 0x0041: "srl     "
			case 0x0060: "sext8   "
			case 0x0061: "sext16  "
			case 0x00E0: "clz     "
			case 0x01E0: "swapb   "
			case 0x01E2: "swaph   "
			default: "DEAD"
		}

	image = format("100100 %s %s %16b", rD, rA, imm)

	action = 
	{
		switch(imm)
		{
			case 0x0001:
				rD = coerce(int(32), rA) >> 1;
				C = rA<31..31>;
			case 0x0021: 
				rD = rA >> 1;
				rD<31..31> = C;
				C = rA<31..31>;
			case 0x0041: 
				rD = rD >> 1;
				C = rA<31..31>;
			case 0x0060: 
				rD = sext32(rA, 8);
			case 0x0061: 
				rD = sext32(rA, 16);
			case 0x00E0:
				_rDST = 31;
				loop;
			case 0x01E0: 
				rD<7..0> = rA<31..24>;
				rD<15..8> = rA<23..16>;
				rD<23..16> = rA<15..8>;
				rD<31..24> = rA<7..0>;
			case 0x01E2: 
				rD<15..0> = rA<31..16>;
				rD<31..16> = rA<15..0>;
		};
	}
	
	// Borrowed from the PPC GLISS specification
	loop = 
	{
		if _rDST >= 0 then
			if rA<_rDST.._rDST> == 0 then
				_rDST = _rDST - 1;
				loop;
			else
				rD = 31 - _rDST;
			endif;
		else
			rD = 32;
		endif;
	}

op MBlaze_typeB_MTS(rA: reg_idx0, spr: card(14))
	syntax = "mts     "
	image = format("100101 00000 %s 11 %14b", rA, spr)
	action = 
	{
		// Not implementing special for now...
	}

op MBlaze_typeB_MFS(setn: bit, copy: bit, rD: reg_idx, spr: card(14))
	syntax = 
		if setn == 1 then
			"msrclr  "
		else
			if copy == 1 then
				"mfs     "
			else
				"msrset  "
			endif
		endif

	image = format("100101 %s 0000 %1b %1b 0 %14b", rD, setn, copy, spr)

	action = 
	{
		// Not implementing special for now...
	}

op MBlaze_typeA_BR(rD: reg_idx, rB: reg_idx0, abs: bit, delayed: bit, linked: bit)
	syntax = format("br%s%s%s", 
					if abs == 1 then "a" else "" endif,
					if linked == 1 then "l" else "" endif,
					if delayed == 1 then "d" else "" endif)

	image = format("100110 %s %1b %1b %1b 00 %s 00000000000", rD, delayed, abs, linked, rB)

	action = 
	{
		if linked == 1 then
			rD = PC;
		endif;

		if delayed == 1 then
			DB = 1;
		else
			B = 1;
		endif;

		if abs == 1 then
			Btgt = rB;
		else
			Btgt = PC + rB;
		endif;
	}

op MBlaze_typeA_BRC(rA: reg_idx0, rB: reg_idx0, delayed: bit, cond: card(3))
	syntax = 
		if delayed == 1 then
			switch(cond)
			{
				case 0: "beqd    "
				case 1: "bned    "
				case 2: "bltd    "
				case 3: "bled    "
				case 4: "bgtd    "
				case 5: "bged    "
				default: "DEAD"
			}
		else
			switch(cond)
			{
				case 0: "beq     "
				case 1: "bne     "
				case 2: "blt     "
				case 3: "ble     "
				case 4: "bgt     "
				case 5: "bge     "
				default: "DEAD"
			}
		endif

	image = format("100111 %1b 0 %3b %s %s 00000000000", delayed, cond, rA, rB)

	action = 
	{
		switch(cond)
		{
			case 0: if coerce(int(32), rA) == 0 then B = 1; else B = 0; endif;
			case 1: if coerce(int(32), rA) != 0 then B = 1; else B = 0; endif;
			case 2: if coerce(int(32), rA) <  0 then B = 1; else B = 0; endif;
			case 3: if coerce(int(32), rA) <= 0 then B = 1; else B = 0; endif;
			case 4: if coerce(int(32), rA) >  0 then B = 1; else B = 0; endif;
			case 5: if coerce(int(32), rA) >= 0 then B = 1; else B = 0; endif;
		};

		if B == 1 then
			Btgt = PC + rB;
		endif;

		if delayed == 1 then
			DB = B;
			B = 0;
		endif;
	}

op MBlaze_typeB_logic(opc: card(2), rD: reg_idx, rA: reg_idx0, imm: imm16)
	syntax = switch(opc)
	{
		case 0: "ori     "
		case 1: "andi    "
		case 2: "xori    "
		case 3: "andni   "
	}

	image = format("1010 %2b %s %s %16b", opc, rD, rA, imm)

	action = 
	{
		immTmp = buildImm(imm);
		immHighValid = 0;

		switch(opc)
		{
			case 0: rD = rA | immTmp;
			case 1: rD = rA & immTmp;
			case 2: rD = rA ^ immTmp;
			case 3: rD = rA & ~immTmp;
		};
	}

op MBlaze_typeB_IMM(imm: imm16)
	syntax = "imm     "
	image = format("101100 00000 00000 %16b", imm)
	action = { immHigh = imm << 16; immHighValid = 1; }

op MBlaze_typeB_RET(intr: bit, brk: bit, exc: bit, rA: reg_idx0, imm: imm16)
	syntax = 
		if intr == 1 then
			"rtid    "
		else
			if brk == 1 then
				"rtbd    "
			else
				if exc == 1 then
					"rted    "
				else
					"rtsd    "
				endif
			endif
		endif

	image = format("101101 10 %1b %1b %1b %s %16b", exc, brk, intr, rA, imm)

	action = 
	{
		DB = 1;
		immTmp = buildImm(imm);
		immHighValid = 0;
		Btgt = rA + immTmp;
	}

op MBlaze_typeB_BR(rD: reg_idx, abs: bit, delayed: bit, linked: bit, imm: imm16)
	syntax = format("br%s%si%s", 
					if abs == 1 then "a" else "" endif,
					if linked == 1 then "l" else "" endif,
					if delayed == 1 then "d" else "" endif)

	image = format("101110 %s %1b %1b %1b 00 %16b", rD, delayed, abs, linked, imm)

	action = 
	{
		immTmp = buildImm(imm);
		immHighValid = 0;

		if linked == 1 then
			rD = PC;
		endif;

		if delayed == 1 then
			DB = 1;
		else
			B = 1;
		endif;

		if abs == 1 then
			Btgt = immTmp;
		else
			Btgt = PC + immTmp;
		endif;
	}

op MBlaze_typeB_BRC(rA: reg_idx0, delayed: bit, cond: card(3), imm: imm16)
	syntax = 
		if delayed == 1 then
			switch(cond)
			{
				case 0: "beqid   "
				case 1: "bneid   "
				case 2: "bltid   "
				case 3: "bleid   "
				case 4: "bgtid   "
				case 5: "bgeid   "
				default: "DEAD"
			}
		else
			switch(cond)
			{
				case 0: "beqi     "
				case 1: "bnei     "
				case 2: "blti     "
				case 3: "blei     "
				case 4: "bgti     "
				case 5: "bgei     "
				default: "DEAD"
			}
		endif

	image = format("101111 %1b 0 %3b %s %16b", delayed, cond, rA, imm)

	action = 
	{
		immTmp = buildImm(imm);
		immHighValid = 0;

		switch(cond)
		{
			case 0: if coerce(int(32), rA) == 0 then B = 1; else B = 0; endif;
			case 1: if coerce(int(32), rA) != 0 then B = 1; else B = 0; endif;
			case 2: if coerce(int(32), rA) <  0 then B = 1; else B = 0; endif;
			case 3: if coerce(int(32), rA) <= 0 then B = 1; else B = 0; endif;
			case 4: if coerce(int(32), rA) >  0 then B = 1; else B = 0; endif;
			case 5: if coerce(int(32), rA) >= 0 then B = 1; else B = 0; endif;
		};

		if B == 1 then
			Btgt = PC + immTmp;
		endif;

		if delayed == 1 then
			DB = B;
			B = 0;
		endif;
	}

op MBlaze_typeA_LD(half: bit, word: bit, reversed: bit, exclusive: bit, rD: reg_idx, rA: reg_idx0, rB: reg_idx0)
	syntax = format("l%s%s%s%s%s", 
					if half == 0 && word == 0 then "b" else "" endif,
					if half == 1 then "h" else "" endif,
					if word == 1 then "w" else "" endif,
					if reversed == 1 then "r" else "" endif,
					if exclusive == 1 then "x" else "" endif)

	image = format("1100 %1b %1b %s %s %s %1b %1b 000000000", word, half, rD, rA, rB, exclusive, reversed)

	action = 
	{
		_rDST = rA + rB;

		// You had better align these yourself...
		// TODO: CHECK ENDIAN-NESS!
		if half == 0 && word == 0 then // Byte load
			rD<7..0> = M[_rDST];
			rD<31..8> = 0;
		else
			if half == 1 then
				rD<15..8> = M[_rDST + 1];
				rD<7..0> = M[_rDST + 0];
				rD<31..16> = 0;
			else
				if word == 1 then
					rD<31..24> = M[_rDST + 3];
					rD<23..16> = M[_rDST + 2];
					rD<15..8> =  M[_rDST + 1];
					rD<7..0> =   M[_rDST + 0];
				endif;
			endif;
		endif;
	}

op MBlaze_typeA_ST(half: bit, word: bit, reversed: bit, exclusive: bit, rD: reg_idx, rA: reg_idx0, rB: reg_idx0)
	syntax = format("s%s%s%s%s%s", 
					if half == 0 && word == 0 then "b" else "" endif,
					if half == 1 then "h" else "" endif,
					if word == 1 then "w" else "" endif,
					if reversed == 1 then "r" else "" endif,
					if exclusive == 1 then "x" else "" endif)

	image = format("1101 %1b %1b %s %s %s %1b %1b 000000000", word, half, rD, rA, rB, exclusive, reversed)

	action = 
	{
		_rDST = rA + rB;

		// You had better align these yourself...
		// TODO: CHECK ENDIAN-NESS!
		if half == 0 && word == 0 then // Byte load
			M[_rDST] = rD<7..0>;
		else
			if half == 1 then
				M[_rDST + 1] = rD<15..8>;
				M[_rDST + 0] = rD<7..0>;
			else
				if word == 1 then
					M[_rDST + 3] = rD<31..24>;
					M[_rDST + 2] = rD<23..16>;
					M[_rDST + 1] = rD<15..8>;
					M[_rDST + 0] = rD<7..0>;
				endif;
			endif;
		endif;
	}

op MBlaze_typeB_LDI(half: bit, word: bit, rD: reg_idx, rA: reg_idx0, imm: imm16)
	syntax = format("l%s%s%si", 
					if half == 0 && word == 0 then "b" else "" endif,
					if half == 1 then "h" else "" endif,
					if word == 1 then "w" else "" endif)

	image = format("1110 %1b %1b %s %s %16b", word, half, rD, rA, imm)

	action = 
	{
		immTmp = buildImm(imm);
		immHighValid = 0;
		_rDST = rA + immTmp;

		// You had better align these yourself...
		// TODO: CHECK ENDIAN-NESS!
		if half == 0 && word == 0 then // Byte load
			rD<7..0> = M[_rDST];
			rD<31..8> = 0;
		else
			if half == 1 then
				rD<15..8> = M[_rDST + 1];
				rD<7..0> = M[_rDST + 0];
				rD<31..16> = 0;
			else
				if word == 1 then
					rD<31..24> = M[_rDST + 3];
					rD<23..16> = M[_rDST + 2];
					rD<15..8> =  M[_rDST + 1];
					rD<7..0> =   M[_rDST + 0];
				endif;
			endif;
		endif;
	}

op MBlaze_typeB_STI(half: bit, word: bit, rD: reg_idx, rA: reg_idx0, imm: imm16)
	syntax = format("s%s%s%si", 
					if half == 0 && word == 0 then "b" else "" endif,
					if half == 1 then "h" else "" endif,
					if word == 1 then "w" else "" endif)

	image = format("1111 %1b %1b %s %s %16b", word, half, rD, rA, imm)

	action = 
	{
		immTmp = buildImm(imm);
		immHighValid = 0;
		_rDST = rA + immTmp;

		// You had better align these yourself...
		// TODO: CHECK ENDIAN-NESS!
		if half == 0 && word == 0 then // Byte load
			M[_rDST] = rD<7..0>;
		else
			if half == 1 then
				M[_rDST + 1] = rD<15..8>;
				M[_rDST + 0] = rD<7..0>;
			else
				if word == 1 then
					M[_rDST + 3] = rD<31..24>;
					M[_rDST + 2] = rD<23..16>;
					M[_rDST + 1] = rD<15..8>;
					M[_rDST + 0] = rD<7..0>;
				endif;
			endif;
		endif;
	}